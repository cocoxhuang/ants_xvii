from sage.all import EllipticCurve, primes, round, Integer, QQ, RR, kronecker, ZZ, GF, NumberField
import copy
from lmfdb import db
import pandas as pd
import json

ecq = db.ec_curvedata

def get_E_data(labels):
    '''
    returns a dictionary of elliptic curves of the format: e.g.
        {'lmfdb_label': {p: a_p, 'conductor': conductor of E, 'L_alg': L_alg(E)} }
        where L_alg(E) = L(E,1) / ( real_period * regulator ), and E has rank 0
    '''
    res = {}

    # Load the elliptic curve table from the LMFDB
    ec_classdata = db.ec_classdata
    ec_mwbsd = db.ec_mwbsd

    # create a dictionary of {'lmfdb_label' : {p : a_p, 'conductor': conductor}}}
    ecq_payload = ecq.search({"lmfdb_label": {"$in": labels}}, projection=['lmfdb_label','conductor','lmfdb_iso','regulator'])
    df_ecq = pd.DataFrame(list(ecq_payload))

    classdata_payload = ec_classdata.search({'lmfdb_iso': {'$in': df_ecq['lmfdb_iso'].tolist()}}, projection=['lmfdb_iso','aplist'])
    df_class = pd.DataFrame(list(classdata_payload))

    # seperate the aplist into individual columns
    my_primes = list(primes(100))
    df_class = df_class.join(pd.DataFrame(df_class['aplist'].tolist(), columns=my_primes))
    df_class = df_class.drop(columns=['aplist'])

    # merge the two dataframes on 'lmfdb_iso'
    merged_df = pd.merge(df_ecq, df_class, on='lmfdb_iso', how='inner')

    mwbsd_payload = ec_mwbsd.search({'lmfdb_label': {'$in': merged_df['lmfdb_label'].tolist()}}, projection=['lmfdb_label','tamagawa_product','real_period','special_value'])
    df_mwbsd = pd.DataFrame(list(mwbsd_payload))

    # merge the two dataframes on 'lmfdb_label'
    merged_df = pd.merge(df_mwbsd, merged_df, on='lmfdb_label', how='inner')

    merged_df['L_alg'] = merged_df['special_value']/(merged_df['real_period'] * merged_df['regulator'])

    # create the final dictionary
    for index, row in merged_df.iterrows():
        lmfdb_label = row['lmfdb_label']
        conductor = row['conductor']
        L_alg = row['L_alg']
        a_p_dict = {p: row[p] for p in my_primes}
        res[lmfdb_label] = {**a_p_dict, 'conductor': conductor, 'L_alg': L_alg}
        E = EllipticCurve(lmfdb_label)
        # res[lmfdb_label]['sha_2'] = E.sha().two_selmer_bound()
        res[lmfdb_label]['sha_2'] = E.selmer_rank() - E.two_torsion_rank() # rank(E) is contrained to be 0
    return res

def generate_qs(E_label, E_data, qs) -> list:
    '''
    Returns a list of BSD verified quadratic twists of the given elliptic curve
    Input:
        E_label: the lmfdb label of the elliptic curve
        E_data: a dictionary of data of one elliptic curve
        qs: a full list of primes
    '''
    res = []

    bad_primes = set([factor for factor, _  in Integer(E_data['conductor']).factor()])
    bad_primes_2 = copy.deepcopy(bad_primes)
    bad_primes_2.add(2)

    E = EllipticCurve(E_label)

    # Create number field from two-division polynomial
    f = E.two_division_polynomial()
    F = NumberField(f, 'a')

    for q in qs:
        if q in bad_primes:
            continue
        if q % 4 != 1:
            continue
        if q in E_data.keys():
            N_q = 1 + q - E_data[q]
        else:
            N_q = 1 + q - E.ap(q)
        if Integer(N_q).valuation(2) != 1 - QQ(RR(E_data['L_alg'])).valuation(2):
            continue

        # do a two descent to verify that sha(E)[2] == sha(E^q)[2]
        # sha_2_E_q = E.quadratic_twist(q).sha().two_selmer_bound()
        sha_2_E_q = E.quadratic_twist(q).selmer_rank() - E.quadratic_twist(q).two_torsion_rank()
        if sha_2_E_q != E_data['sha_2']:
            continue

        # Check if the ideal generated by q in the number field is prime
        I = F.ideal(q)
        if not I.is_prime():
            continue

        res.append(int(q))   # if all are satisfied, add q to the list

    return res

def generate_BSD_quadratic_twists(labels: list, primes_bound : int =100) -> dict:
    ''' Returns a dictionary of elliptic curves and their BSD verified quadratic twists

    Args:
        labels: a list of lmfdb labels of elliptic curves
        primes_bound: an upper bound for the primes to be considered as potential twists
    '''
    res = {}

    qs = primes(primes_bound) # must be prime
    qs = [p for p in qs if p % 4 == 1]

    E_dict = get_E_data(labels)

    for E_label, E_data in E_dict.items():
        res[E_label] = generate_qs(E_label, E_data, qs)
    return res

if __name__ == "__main__":

    labels_path = 'data/lmfdb_labels.txt'

    # load labels from file
    labels = []
    with open(labels_path, 'r') as file:
        for line in file:
            try:
                label, source = line.strip().split(', ')
                if source == 'Zhai16-2_torsion' or source == 'Zhai16-no_2_torsion':
                    labels.append(label)
            except: # otherwise it's not formatted to be label, source
                continue
    
    B = 500 # an upper bound for M
    res = {}

    # main computation
    res = generate_BSD_quadratic_twists(labels, primes_bound=B)

    with open('data/Zhai_res.json', 'w') as f:
        json.dump(res, f, indent=4)
